; To increase performance 'map' was implemented as Primitive
;(define (map func  li)
;    (if (nil? li)
;        '()
;        (cons
;            (apply func (list (car li)))
;            (map func (cdr li))
;        )
;))

; To increase performance 'filter' was implemented as Primitive
;(define (filter func  li)
;    (print li)
;    (if (nil? li)
;        '()
;        (if (func (car li))  (cons (car li) (filter func (cdr li)))   (filter func (cdr li)))        
;))


; To increase performance 'mapall' was implemented as Primitive
;(define (mapall func  li)
;    (if (nil? li)
;        '()
;        (cons
;            (if (list? (car li)) (mapall func (car li)) (func (car li)))
;            (mapall func (cdr li))
;        )
;))



(defmacro (letrec clauses . body)
  :doc "Binds variables with mutual recursion support."

  `((lambda ,(map car clauses)

      ,@(map (lambda (clause)

	       `(set! ,(car clause) ,(cadr clause)))

	     clauses)

      ,@body)

    ,@(map (lambda (c) #f) clauses)))



;(define (applay . args) (print args) (eval args))




(define (quit)
  :doc "Exits the JLLL interpreter."
  (invoke-static 'java.lang.System 'exit 0))

(define exit
  :doc "Exits the JLLL interpreter."
  quit)
