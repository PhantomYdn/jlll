; To increase performance 'map' was implemented as Primitive
;(define (map func  li)
;    (if (nil? li)
;        '()
;        (cons
;            (apply func (list (car li)))
;            (map func (cdr li))
;        )
;))

; To increase performance 'filter' was implemented as Primitive
;(define (filter func  li)
;    (print li)
;    (if (nil? li)
;        '()
;        (if (func (car li))  (cons (car li) (filter func (cdr li)))   (filter func (cdr li)))        
;))


; To increase performance 'mapall' was implemented as Primitive
;(define (mapall func  li)
;    (if (nil? li)
;        '()
;        (cons
;            (if (list? (car li)) (mapall func (car li)) (func (car li)))
;            (mapall func (cdr li))
;        )
;))



(defmacro (letrec clauses . body)
  :doc "Binds variables with mutual recursion support."

  `((lambda ,(map car clauses)

      ,@(map (lambda (clause)

	       `(set! ,(car clause) ,(cadr clause)))

	     clauses)

      ,@body)

    ,@(map (lambda (c) false) clauses)))


;; ============== Control Flow Macros ==============

(defmacro (when test . body)
  :doc "Evaluates body forms if test is true. Returns false if test is false."
  `(if ,test (begin ,@body) false))

(defmacro (unless test . body)
  :doc "Evaluates body forms if test is false. Returns false if test is true."
  `(if ,test false (begin ,@body)))

(defmacro (let* bindings . body)
  :doc "Sequential local bindings. Each binding can reference previous ones."
  (if (null? bindings)
      `(begin ,@body)
      `(let (,(car bindings))
         (let* ,(cdr bindings) ,@body))))

(defmacro (dotimes var-count . body)
  :doc "Counted iteration. (dotimes (var count) body...) binds var to 0, 1, ..., count-1."
  `(let ((%dotimes-count% ,(cadr var-count)))
     (define (%dotimes-loop% ,(car var-count))
       (if (< ,(car var-count) %dotimes-count%)
           (begin ,@body (%dotimes-loop% (+ ,(car var-count) 1)))
           false))
     (%dotimes-loop% 0)))

(defmacro (dolist var-list . body)
  :doc "List iteration. (dolist (var list) body...) binds var to each element."
  `(let ((%dolist-list% ,(cadr var-list)))
     (define (%dolist-loop% %dolist-rest%)
       (if (null? %dolist-rest%)
           false
           (let ((,(car var-list) (car %dolist-rest%)))
             ,@body
             (%dolist-loop% (cdr %dolist-rest%)))))
     (%dolist-loop% %dolist-list%)))

;; do - R5RS general iteration
;; (do ((var init step) ...) (test result) body ...)
(defmacro (do bindings test-result . body)
  :doc "R5RS general iteration. (do ((i 0 (+ i 1))) ((>= i 10) i) (println i))"
  (let ((vars (map car bindings))
        (inits (map cadr bindings))
        (steps (map (lambda (b) (if (null? (cddr b)) (car b) (caddr b))) bindings))
        (test (car test-result))
        (result (if (null? (cdr test-result)) false (cadr test-result)))
        (loop-name (gensym "do-loop")))
    `(let ,loop-name ,(map list vars inits)
       (if ,test
           ,result
           (begin
             ,@body
             (,loop-name ,@steps))))))



;(define (apply . args) (print args) (eval args))




(define (quit)
  :doc "Exits the JLLL interpreter."
  (invoke-static 'java.lang.System 'exit 0))

(define exit
  :doc "Exits the JLLL interpreter."
  quit)
